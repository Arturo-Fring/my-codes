import numpy as np

# псевдослучайные числа образуют одну и ту же последовательность (при каждом запуске)
np.random.seed(0)
x = np.arange(-1.0, 1.0, 0.1)  # аргумент [-1; 1] с шагом 0,1


def model_a(xx, ww): return (ww[0] + ww[1] * xx)  # модель


# вектор целевых значений
Y = -5.2 + 0.7 * x + np.random.normal(0, 0.1, len(x))

# здесь продолжайте программу
# Сформируйте обучающую выборку X в виде матрицы
# И вычислите коэффициенты w используя следующий функционал качества (средний эмпирический риск при квадратической функции потерь):
_ = np.ones((len(x), 1))
X = np.column_stack([_, x])
w = np.linalg.inv((X.T@X)) @ X.T@Y


a = np.arange(1, 7)   # [1 2 3 4 5 6]

# Сделать матрицу 2x3
A = a.reshape(2, 3)
print(A)
print('===')
print(A[0])
A[0] = 1
print(A[0])
print('===')
# Сделать вектор-столбец
b = a.reshape(-1, 1)   # "-1" значит "подбери размер автоматически"
print(b)
