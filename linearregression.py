import numpy as np

# Входные данные (признаки)
x = np.arange(-1.0, 1.0, 0.1)  # [)
print(x)

# Модель линейной регрессии
w = [0.5, -0.3]
def model_a(m_x, m_w): return (m_w[1] * m_x + m_w[0])


# Это реальные данные. Берём "истинную прямую", добавляем шум
y = model_a(x, w) + np.random.normal(0, 0.1, len(x))

# То что посчитала модель
y_pred = model_a(x, w)

# Квадратичная ошибка без усреднения


def loss(ax, y): return (ax - y) ** 2

# Чтобы посчитать ошибку, нужно:
# Посчитать модельные данные, и реальные.


# Получается, что можно вычесть оба этих массива
error = loss(y_pred, y)

Q = 1/len(x)*np.sum(error)

print(Q)
