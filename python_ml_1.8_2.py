# task 1.8_1
import numpy as np

# Значения функции (целевые?)


def func(x):
    return 0.5 * x**2 - 0.1 * 1/np.exp(-x) + 0.5 * np.cos(2*x) - 2.


# здесь объявляйте дополнительные функции (если необходимо)


# значения отсчетов по оси абсцисс по сути (x1)
coord_x = np.arange(-5.0, 5.0, 0.1)
coord_y = func(coord_x)  # значения функции по оси ординат по сути (x2)

sz = len(coord_x)  # общее число отсчетов (число точек)

# здесь продолжайте программу
# model
# Уже известные веса для модели
w = np.array([-1.59, -0.69, 0.278, 0.497, -0.106])
# Сама модель (возвращает спрогнозируемые данные)
# на входе вектор xi, веса
def a(x, w): return w[0]+w[1]*x+w[2]*x**2+w[3]*np.cos(2*x)+w[4]*np.sin(2*x)
# вектор x имеет размерность sz


# Тогда массив прогнозируемых чисел
y_model = a(coord_x, w)

# print(y_model.shape, coord_y.shape)
# Квадратичная функция потерь
loss_abs = abs((np.array(y_model)-coord_y))
Q = np.average(loss_abs)
print(Q)
