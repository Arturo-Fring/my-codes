# task 1.8_1
import numpy as np

# Значения функции (целевые?)


def func(x):
    return 0.1 * x**2 - np.sin(x) + 0.1 * np.cos(x * 5) + 1.


# здесь объявляйте дополнительные функции (если необходимо)


# значения отсчетов по оси абсцисс по сути (x1)
coord_x = np.arange(-5.0, 5.0, 0.1)
coord_y = func(coord_x)  # значения функции по оси ординат по сути (x2)

sz = len(coord_x)  # общее число отсчетов (число точек)

# здесь продолжайте программу
# model
# Уже известные веса для модели
w = np.array([1.11, -0.26, 0.061, 0.0226, 0.00178])
# Сама модель (возвращает спрогнозируемые данные)
# на входе вектор xi, веса
def a(x, w): return w[0]+w[1]*x+w[2]*x*x+w[3]*x*x*x+w[4]*x*x*x*x
# вектор x имеет размерность sz


# Тогда массив прогнозируемых чисел
y_model = a(coord_x, w)

# print(y_model.shape, coord_y.shape)
# Квадратичная функция потерь
loss_sq = (np.array(y_model)-coord_y)**2
Q = 1/sz*np.sum(loss_sq)
print(Q)
